// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: imageMessage.proto

#ifndef PROTOBUF_imageMessage_2eproto__INCLUDED
#define PROTOBUF_imageMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers. 
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ladybug5_network {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_imageMessage_2eproto();
void protobuf_AssignDesc_imageMessage_2eproto();
void protobuf_ShutdownFile_imageMessage_2eproto();

class LadybugTimeStamp;
class pbDisortion;
class pbPosition;
class pbFloatTriblet;
class pbImage;
class pbSensor;
class pbMessage;

enum ImageType {
  LADYBUG_RAW_CAM0 = 1,
  LADYBUG_RAW_CAM1 = 2,
  LADYBUG_RAW_CAM2 = 4,
  LADYBUG_RAW_CAM3 = 8,
  LADYBUG_RAW_CAM4 = 16,
  LADYBUG_RAW_CAM5 = 32,
  LADYBUG_ALL_RAW_IMAGES = 63,
  LADYBUG_RECTIFIED_CAM0 = 64,
  LADYBUG_RECTIFIED_CAM1 = 128,
  LADYBUG_RECTIFIED_CAM2 = 256,
  LADYBUG_RECTIFIED_CAM3 = 512,
  LADYBUG_RECTIFIED_CAM4 = 1024,
  LADYBUG_RECTIFIED_CAM5 = 2048,
  LADYBUG_ALL_RECTIFIED_IMAGES = 4032,
  LADYBUG_PANORAMIC = 4096,
  LADYBUG_DOME = 8192,
  LADYBUG_SPHERICAL = 16384,
  LADYBUG_ALL_CAMERAS_VIEW = 32768,
  LADYBUG_ALL_OUTPUT_IMAGE = 2147483647
};
bool ImageType_IsValid(int value);
const ImageType ImageType_MIN = LADYBUG_RAW_CAM0;
const ImageType ImageType_MAX = LADYBUG_ALL_OUTPUT_IMAGE;
const int ImageType_ARRAYSIZE = ImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageType_descriptor();
inline const ::std::string& ImageType_Name(ImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageType_descriptor(), value);
}
inline bool ImageType_Parse(
    const ::std::string& name, ImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageType>(
    ImageType_descriptor(), name, value);
}
// ===================================================================

class LadybugTimeStamp : public ::google::protobuf::Message {
 public:
  LadybugTimeStamp();
  virtual ~LadybugTimeStamp();

  LadybugTimeStamp(const LadybugTimeStamp& from);

  inline LadybugTimeStamp& operator=(const LadybugTimeStamp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LadybugTimeStamp& default_instance();

  void Swap(LadybugTimeStamp* other);

  // implements Message ----------------------------------------------

  LadybugTimeStamp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LadybugTimeStamp& from);
  void MergeFrom(const LadybugTimeStamp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ulSeconds = 1;
  inline bool has_ulseconds() const;
  inline void clear_ulseconds();
  static const int kUlSecondsFieldNumber = 1;
  inline ::google::protobuf::uint64 ulseconds() const;
  inline void set_ulseconds(::google::protobuf::uint64 value);

  // required uint64 ulMicroSeconds = 2;
  inline bool has_ulmicroseconds() const;
  inline void clear_ulmicroseconds();
  static const int kUlMicroSecondsFieldNumber = 2;
  inline ::google::protobuf::uint64 ulmicroseconds() const;
  inline void set_ulmicroseconds(::google::protobuf::uint64 value);

  // optional uint64 ulCycleSeconds = 3;
  inline bool has_ulcycleseconds() const;
  inline void clear_ulcycleseconds();
  static const int kUlCycleSecondsFieldNumber = 3;
  inline ::google::protobuf::uint64 ulcycleseconds() const;
  inline void set_ulcycleseconds(::google::protobuf::uint64 value);

  // optional uint64 ulCycleCount = 4;
  inline bool has_ulcyclecount() const;
  inline void clear_ulcyclecount();
  static const int kUlCycleCountFieldNumber = 4;
  inline ::google::protobuf::uint64 ulcyclecount() const;
  inline void set_ulcyclecount(::google::protobuf::uint64 value);

  // optional uint64 ulCycleOffset = 5;
  inline bool has_ulcycleoffset() const;
  inline void clear_ulcycleoffset();
  static const int kUlCycleOffsetFieldNumber = 5;
  inline ::google::protobuf::uint64 ulcycleoffset() const;
  inline void set_ulcycleoffset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ladybug5_network.LadybugTimeStamp)
 private:
  inline void set_has_ulseconds();
  inline void clear_has_ulseconds();
  inline void set_has_ulmicroseconds();
  inline void clear_has_ulmicroseconds();
  inline void set_has_ulcycleseconds();
  inline void clear_has_ulcycleseconds();
  inline void set_has_ulcyclecount();
  inline void clear_has_ulcyclecount();
  inline void set_has_ulcycleoffset();
  inline void clear_has_ulcycleoffset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 ulseconds_;
  ::google::protobuf::uint64 ulmicroseconds_;
  ::google::protobuf::uint64 ulcycleseconds_;
  ::google::protobuf::uint64 ulcyclecount_;
  ::google::protobuf::uint64 ulcycleoffset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_imageMessage_2eproto();
  friend void protobuf_AssignDesc_imageMessage_2eproto();
  friend void protobuf_ShutdownFile_imageMessage_2eproto();

  void InitAsDefaultInstance();
  static LadybugTimeStamp* default_instance_;
};
// -------------------------------------------------------------------

class pbDisortion : public ::google::protobuf::Message {
 public:
  pbDisortion();
  virtual ~pbDisortion();

  pbDisortion(const pbDisortion& from);

  inline pbDisortion& operator=(const pbDisortion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbDisortion& default_instance();

  void Swap(pbDisortion* other);

  // implements Message ----------------------------------------------

  pbDisortion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbDisortion& from);
  void MergeFrom(const pbDisortion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double focalX = 1;
  inline bool has_focalx() const;
  inline void clear_focalx();
  static const int kFocalXFieldNumber = 1;
  inline double focalx() const;
  inline void set_focalx(double value);

  // optional double focalY = 2;
  inline bool has_focaly() const;
  inline void clear_focaly();
  static const int kFocalYFieldNumber = 2;
  inline double focaly() const;
  inline void set_focaly(double value);

  // optional double centerX = 3;
  inline bool has_centerx() const;
  inline void clear_centerx();
  static const int kCenterXFieldNumber = 3;
  inline double centerx() const;
  inline void set_centerx(double value);

  // optional double centerY = 4;
  inline bool has_centery() const;
  inline void clear_centery();
  static const int kCenterYFieldNumber = 4;
  inline double centery() const;
  inline void set_centery(double value);

  // @@protoc_insertion_point(class_scope:ladybug5_network.pbDisortion)
 private:
  inline void set_has_focalx();
  inline void clear_has_focalx();
  inline void set_has_focaly();
  inline void clear_has_focaly();
  inline void set_has_centerx();
  inline void clear_has_centerx();
  inline void set_has_centery();
  inline void clear_has_centery();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double focalx_;
  double focaly_;
  double centerx_;
  double centery_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_imageMessage_2eproto();
  friend void protobuf_AssignDesc_imageMessage_2eproto();
  friend void protobuf_ShutdownFile_imageMessage_2eproto();

  void InitAsDefaultInstance();
  static pbDisortion* default_instance_;
};
// -------------------------------------------------------------------

class pbPosition : public ::google::protobuf::Message {
 public:
  pbPosition();
  virtual ~pbPosition();

  pbPosition(const pbPosition& from);

  inline pbPosition& operator=(const pbPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbPosition& default_instance();

  void Swap(pbPosition* other);

  // implements Message ----------------------------------------------

  pbPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbPosition& from);
  void MergeFrom(const pbPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double Rx = 1;
  inline bool has_rx() const;
  inline void clear_rx();
  static const int kRxFieldNumber = 1;
  inline double rx() const;
  inline void set_rx(double value);

  // required double Ry = 2;
  inline bool has_ry() const;
  inline void clear_ry();
  static const int kRyFieldNumber = 2;
  inline double ry() const;
  inline void set_ry(double value);

  // required double Rz = 3;
  inline bool has_rz() const;
  inline void clear_rz();
  static const int kRzFieldNumber = 3;
  inline double rz() const;
  inline void set_rz(double value);

  // required double Tx = 4;
  inline bool has_tx() const;
  inline void clear_tx();
  static const int kTxFieldNumber = 4;
  inline double tx() const;
  inline void set_tx(double value);

  // required double Ty = 5;
  inline bool has_ty() const;
  inline void clear_ty();
  static const int kTyFieldNumber = 5;
  inline double ty() const;
  inline void set_ty(double value);

  // required double Tz = 6;
  inline bool has_tz() const;
  inline void clear_tz();
  static const int kTzFieldNumber = 6;
  inline double tz() const;
  inline void set_tz(double value);

  // @@protoc_insertion_point(class_scope:ladybug5_network.pbPosition)
 private:
  inline void set_has_rx();
  inline void clear_has_rx();
  inline void set_has_ry();
  inline void clear_has_ry();
  inline void set_has_rz();
  inline void clear_has_rz();
  inline void set_has_tx();
  inline void clear_has_tx();
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_tz();
  inline void clear_has_tz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double rx_;
  double ry_;
  double rz_;
  double tx_;
  double ty_;
  double tz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_imageMessage_2eproto();
  friend void protobuf_AssignDesc_imageMessage_2eproto();
  friend void protobuf_ShutdownFile_imageMessage_2eproto();

  void InitAsDefaultInstance();
  static pbPosition* default_instance_;
};
// -------------------------------------------------------------------

class pbFloatTriblet : public ::google::protobuf::Message {
 public:
  pbFloatTriblet();
  virtual ~pbFloatTriblet();

  pbFloatTriblet(const pbFloatTriblet& from);

  inline pbFloatTriblet& operator=(const pbFloatTriblet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbFloatTriblet& default_instance();

  void Swap(pbFloatTriblet* other);

  // implements Message ----------------------------------------------

  pbFloatTriblet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbFloatTriblet& from);
  void MergeFrom(const pbFloatTriblet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float Z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:ladybug5_network.pbFloatTriblet)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_imageMessage_2eproto();
  friend void protobuf_AssignDesc_imageMessage_2eproto();
  friend void protobuf_ShutdownFile_imageMessage_2eproto();

  void InitAsDefaultInstance();
  static pbFloatTriblet* default_instance_;
};
// -------------------------------------------------------------------

class pbImage : public ::google::protobuf::Message {
 public:
  pbImage();
  virtual ~pbImage();

  pbImage(const pbImage& from);

  inline pbImage& operator=(const pbImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbImage& default_instance();

  void Swap(pbImage* other);

  // implements Message ----------------------------------------------

  pbImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbImage& from);
  void MergeFrom(const pbImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 number = 6;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 6;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // optional .ladybug5_network.ImageType type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::ladybug5_network::ImageType type() const;
  inline void set_type(::ladybug5_network::ImageType value);

  // optional bytes image = 8;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 8;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const void* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional uint32 size = 9;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // optional string name = 11;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 11;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 height = 12;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 12;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional uint32 width = 13;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 13;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 packages = 14;
  inline bool has_packages() const;
  inline void clear_packages();
  static const int kPackagesFieldNumber = 14;
  inline ::google::protobuf::uint32 packages() const;
  inline void set_packages(::google::protobuf::uint32 value);

  // optional .ladybug5_network.pbDisortion distortion = 15;
  inline bool has_distortion() const;
  inline void clear_distortion();
  static const int kDistortionFieldNumber = 15;
  inline const ::ladybug5_network::pbDisortion& distortion() const;
  inline ::ladybug5_network::pbDisortion* mutable_distortion();
  inline ::ladybug5_network::pbDisortion* release_distortion();
  inline void set_allocated_distortion(::ladybug5_network::pbDisortion* distortion);

  // optional .ladybug5_network.pbPosition position = 16;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 16;
  inline const ::ladybug5_network::pbPosition& position() const;
  inline ::ladybug5_network::pbPosition* mutable_position();
  inline ::ladybug5_network::pbPosition* release_position();
  inline void set_allocated_position(::ladybug5_network::pbPosition* position);

  // optional string bayer_encoding = 17;
  inline bool has_bayer_encoding() const;
  inline void clear_bayer_encoding();
  static const int kBayerEncodingFieldNumber = 17;
  inline const ::std::string& bayer_encoding() const;
  inline void set_bayer_encoding(const ::std::string& value);
  inline void set_bayer_encoding(const char* value);
  inline void set_bayer_encoding(const char* value, size_t size);
  inline ::std::string* mutable_bayer_encoding();
  inline ::std::string* release_bayer_encoding();
  inline void set_allocated_bayer_encoding(::std::string* bayer_encoding);

  // optional string color_encoding = 18;
  inline bool has_color_encoding() const;
  inline void clear_color_encoding();
  static const int kColorEncodingFieldNumber = 18;
  inline const ::std::string& color_encoding() const;
  inline void set_color_encoding(const ::std::string& value);
  inline void set_color_encoding(const char* value);
  inline void set_color_encoding(const char* value, size_t size);
  inline ::std::string* mutable_color_encoding();
  inline ::std::string* release_color_encoding();
  inline void set_allocated_color_encoding(::std::string* color_encoding);

  // @@protoc_insertion_point(class_scope:ladybug5_network.pbImage)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_packages();
  inline void clear_has_packages();
  inline void set_has_distortion();
  inline void clear_has_distortion();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_bayer_encoding();
  inline void clear_has_bayer_encoding();
  inline void set_has_color_encoding();
  inline void clear_has_color_encoding();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 number_;
  int type_;
  ::std::string* image_;
  ::std::string* name_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 packages_;
  ::ladybug5_network::pbDisortion* distortion_;
  ::ladybug5_network::pbPosition* position_;
  ::std::string* bayer_encoding_;
  ::std::string* color_encoding_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_imageMessage_2eproto();
  friend void protobuf_AssignDesc_imageMessage_2eproto();
  friend void protobuf_ShutdownFile_imageMessage_2eproto();

  void InitAsDefaultInstance();
  static pbImage* default_instance_;
};
// -------------------------------------------------------------------

class pbSensor : public ::google::protobuf::Message {
 public:
  pbSensor();
  virtual ~pbSensor();

  pbSensor(const pbSensor& from);

  inline pbSensor& operator=(const pbSensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbSensor& default_instance();

  void Swap(pbSensor* other);

  // implements Message ----------------------------------------------

  pbSensor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbSensor& from);
  void MergeFrom(const pbSensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 temperature = 1;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 1;
  inline ::google::protobuf::uint32 temperature() const;
  inline void set_temperature(::google::protobuf::uint32 value);

  // optional uint32 barometer = 2;
  inline bool has_barometer() const;
  inline void clear_barometer();
  static const int kBarometerFieldNumber = 2;
  inline ::google::protobuf::uint32 barometer() const;
  inline void set_barometer(::google::protobuf::uint32 value);

  // optional uint32 humidity = 3;
  inline bool has_humidity() const;
  inline void clear_humidity();
  static const int kHumidityFieldNumber = 3;
  inline ::google::protobuf::uint32 humidity() const;
  inline void set_humidity(::google::protobuf::uint32 value);

  // optional .ladybug5_network.pbFloatTriblet compass = 4;
  inline bool has_compass() const;
  inline void clear_compass();
  static const int kCompassFieldNumber = 4;
  inline const ::ladybug5_network::pbFloatTriblet& compass() const;
  inline ::ladybug5_network::pbFloatTriblet* mutable_compass();
  inline ::ladybug5_network::pbFloatTriblet* release_compass();
  inline void set_allocated_compass(::ladybug5_network::pbFloatTriblet* compass);

  // optional .ladybug5_network.pbFloatTriblet accelerometer = 5;
  inline bool has_accelerometer() const;
  inline void clear_accelerometer();
  static const int kAccelerometerFieldNumber = 5;
  inline const ::ladybug5_network::pbFloatTriblet& accelerometer() const;
  inline ::ladybug5_network::pbFloatTriblet* mutable_accelerometer();
  inline ::ladybug5_network::pbFloatTriblet* release_accelerometer();
  inline void set_allocated_accelerometer(::ladybug5_network::pbFloatTriblet* accelerometer);

  // optional .ladybug5_network.pbFloatTriblet gyroscope = 6;
  inline bool has_gyroscope() const;
  inline void clear_gyroscope();
  static const int kGyroscopeFieldNumber = 6;
  inline const ::ladybug5_network::pbFloatTriblet& gyroscope() const;
  inline ::ladybug5_network::pbFloatTriblet* mutable_gyroscope();
  inline ::ladybug5_network::pbFloatTriblet* release_gyroscope();
  inline void set_allocated_gyroscope(::ladybug5_network::pbFloatTriblet* gyroscope);

  // @@protoc_insertion_point(class_scope:ladybug5_network.pbSensor)
 private:
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_barometer();
  inline void clear_has_barometer();
  inline void set_has_humidity();
  inline void clear_has_humidity();
  inline void set_has_compass();
  inline void clear_has_compass();
  inline void set_has_accelerometer();
  inline void clear_has_accelerometer();
  inline void set_has_gyroscope();
  inline void clear_has_gyroscope();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 temperature_;
  ::google::protobuf::uint32 barometer_;
  ::ladybug5_network::pbFloatTriblet* compass_;
  ::ladybug5_network::pbFloatTriblet* accelerometer_;
  ::ladybug5_network::pbFloatTriblet* gyroscope_;
  ::google::protobuf::uint32 humidity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_imageMessage_2eproto();
  friend void protobuf_AssignDesc_imageMessage_2eproto();
  friend void protobuf_ShutdownFile_imageMessage_2eproto();

  void InitAsDefaultInstance();
  static pbSensor* default_instance_;
};
// -------------------------------------------------------------------

class pbMessage : public ::google::protobuf::Message {
 public:
  pbMessage();
  virtual ~pbMessage();

  pbMessage(const pbMessage& from);

  inline pbMessage& operator=(const pbMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbMessage& default_instance();

  void Swap(pbMessage* other);

  // implements Message ----------------------------------------------

  pbMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbMessage& from);
  void MergeFrom(const pbMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string camera = 1;
  inline bool has_camera() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 1;
  inline const ::std::string& camera() const;
  inline void set_camera(const ::std::string& value);
  inline void set_camera(const char* value);
  inline void set_camera(const char* value, size_t size);
  inline ::std::string* mutable_camera();
  inline ::std::string* release_camera();
  inline void set_allocated_camera(::std::string* camera);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .ladybug5_network.pbImage Images = 4;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 4;
  inline const ::ladybug5_network::pbImage& images(int index) const;
  inline ::ladybug5_network::pbImage* mutable_images(int index);
  inline ::ladybug5_network::pbImage* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::ladybug5_network::pbImage >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::ladybug5_network::pbImage >*
      mutable_images();

  // required .ladybug5_network.LadybugTimeStamp time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::ladybug5_network::LadybugTimeStamp& time() const;
  inline ::ladybug5_network::LadybugTimeStamp* mutable_time();
  inline ::ladybug5_network::LadybugTimeStamp* release_time();
  inline void set_allocated_time(::ladybug5_network::LadybugTimeStamp* time);

  // optional .ladybug5_network.pbSensor sensors = 6;
  inline bool has_sensors() const;
  inline void clear_sensors();
  static const int kSensorsFieldNumber = 6;
  inline const ::ladybug5_network::pbSensor& sensors() const;
  inline ::ladybug5_network::pbSensor* mutable_sensors();
  inline ::ladybug5_network::pbSensor* release_sensors();
  inline void set_allocated_sensors(::ladybug5_network::pbSensor* sensors);

  // optional string serial_number = 7;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 7;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const char* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // @@protoc_insertion_point(class_scope:ladybug5_network.pbMessage)
 private:
  inline void set_has_camera();
  inline void clear_has_camera();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_sensors();
  inline void clear_has_sensors();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* camera_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::ladybug5_network::pbImage > images_;
  ::ladybug5_network::LadybugTimeStamp* time_;
  ::ladybug5_network::pbSensor* sensors_;
  ::std::string* serial_number_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_imageMessage_2eproto();
  friend void protobuf_AssignDesc_imageMessage_2eproto();
  friend void protobuf_ShutdownFile_imageMessage_2eproto();

  void InitAsDefaultInstance();
  static pbMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// LadybugTimeStamp

// required uint64 ulSeconds = 1;
inline bool LadybugTimeStamp::has_ulseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LadybugTimeStamp::set_has_ulseconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LadybugTimeStamp::clear_has_ulseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LadybugTimeStamp::clear_ulseconds() {
  ulseconds_ = GOOGLE_ULONGLONG(0);
  clear_has_ulseconds();
}
inline ::google::protobuf::uint64 LadybugTimeStamp::ulseconds() const {
  return ulseconds_;
}
inline void LadybugTimeStamp::set_ulseconds(::google::protobuf::uint64 value) {
  set_has_ulseconds();
  ulseconds_ = value;
}

// required uint64 ulMicroSeconds = 2;
inline bool LadybugTimeStamp::has_ulmicroseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LadybugTimeStamp::set_has_ulmicroseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LadybugTimeStamp::clear_has_ulmicroseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LadybugTimeStamp::clear_ulmicroseconds() {
  ulmicroseconds_ = GOOGLE_ULONGLONG(0);
  clear_has_ulmicroseconds();
}
inline ::google::protobuf::uint64 LadybugTimeStamp::ulmicroseconds() const {
  return ulmicroseconds_;
}
inline void LadybugTimeStamp::set_ulmicroseconds(::google::protobuf::uint64 value) {
  set_has_ulmicroseconds();
  ulmicroseconds_ = value;
}

// optional uint64 ulCycleSeconds = 3;
inline bool LadybugTimeStamp::has_ulcycleseconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LadybugTimeStamp::set_has_ulcycleseconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LadybugTimeStamp::clear_has_ulcycleseconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LadybugTimeStamp::clear_ulcycleseconds() {
  ulcycleseconds_ = GOOGLE_ULONGLONG(0);
  clear_has_ulcycleseconds();
}
inline ::google::protobuf::uint64 LadybugTimeStamp::ulcycleseconds() const {
  return ulcycleseconds_;
}
inline void LadybugTimeStamp::set_ulcycleseconds(::google::protobuf::uint64 value) {
  set_has_ulcycleseconds();
  ulcycleseconds_ = value;
}

// optional uint64 ulCycleCount = 4;
inline bool LadybugTimeStamp::has_ulcyclecount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LadybugTimeStamp::set_has_ulcyclecount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LadybugTimeStamp::clear_has_ulcyclecount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LadybugTimeStamp::clear_ulcyclecount() {
  ulcyclecount_ = GOOGLE_ULONGLONG(0);
  clear_has_ulcyclecount();
}
inline ::google::protobuf::uint64 LadybugTimeStamp::ulcyclecount() const {
  return ulcyclecount_;
}
inline void LadybugTimeStamp::set_ulcyclecount(::google::protobuf::uint64 value) {
  set_has_ulcyclecount();
  ulcyclecount_ = value;
}

// optional uint64 ulCycleOffset = 5;
inline bool LadybugTimeStamp::has_ulcycleoffset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LadybugTimeStamp::set_has_ulcycleoffset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LadybugTimeStamp::clear_has_ulcycleoffset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LadybugTimeStamp::clear_ulcycleoffset() {
  ulcycleoffset_ = GOOGLE_ULONGLONG(0);
  clear_has_ulcycleoffset();
}
inline ::google::protobuf::uint64 LadybugTimeStamp::ulcycleoffset() const {
  return ulcycleoffset_;
}
inline void LadybugTimeStamp::set_ulcycleoffset(::google::protobuf::uint64 value) {
  set_has_ulcycleoffset();
  ulcycleoffset_ = value;
}

// -------------------------------------------------------------------

// pbDisortion

// optional double focalX = 1;
inline bool pbDisortion::has_focalx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbDisortion::set_has_focalx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbDisortion::clear_has_focalx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbDisortion::clear_focalx() {
  focalx_ = 0;
  clear_has_focalx();
}
inline double pbDisortion::focalx() const {
  return focalx_;
}
inline void pbDisortion::set_focalx(double value) {
  set_has_focalx();
  focalx_ = value;
}

// optional double focalY = 2;
inline bool pbDisortion::has_focaly() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbDisortion::set_has_focaly() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbDisortion::clear_has_focaly() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbDisortion::clear_focaly() {
  focaly_ = 0;
  clear_has_focaly();
}
inline double pbDisortion::focaly() const {
  return focaly_;
}
inline void pbDisortion::set_focaly(double value) {
  set_has_focaly();
  focaly_ = value;
}

// optional double centerX = 3;
inline bool pbDisortion::has_centerx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbDisortion::set_has_centerx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbDisortion::clear_has_centerx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbDisortion::clear_centerx() {
  centerx_ = 0;
  clear_has_centerx();
}
inline double pbDisortion::centerx() const {
  return centerx_;
}
inline void pbDisortion::set_centerx(double value) {
  set_has_centerx();
  centerx_ = value;
}

// optional double centerY = 4;
inline bool pbDisortion::has_centery() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbDisortion::set_has_centery() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbDisortion::clear_has_centery() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbDisortion::clear_centery() {
  centery_ = 0;
  clear_has_centery();
}
inline double pbDisortion::centery() const {
  return centery_;
}
inline void pbDisortion::set_centery(double value) {
  set_has_centery();
  centery_ = value;
}

// -------------------------------------------------------------------

// pbPosition

// required double Rx = 1;
inline bool pbPosition::has_rx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbPosition::set_has_rx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbPosition::clear_has_rx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbPosition::clear_rx() {
  rx_ = 0;
  clear_has_rx();
}
inline double pbPosition::rx() const {
  return rx_;
}
inline void pbPosition::set_rx(double value) {
  set_has_rx();
  rx_ = value;
}

// required double Ry = 2;
inline bool pbPosition::has_ry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbPosition::set_has_ry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbPosition::clear_has_ry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbPosition::clear_ry() {
  ry_ = 0;
  clear_has_ry();
}
inline double pbPosition::ry() const {
  return ry_;
}
inline void pbPosition::set_ry(double value) {
  set_has_ry();
  ry_ = value;
}

// required double Rz = 3;
inline bool pbPosition::has_rz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbPosition::set_has_rz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbPosition::clear_has_rz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbPosition::clear_rz() {
  rz_ = 0;
  clear_has_rz();
}
inline double pbPosition::rz() const {
  return rz_;
}
inline void pbPosition::set_rz(double value) {
  set_has_rz();
  rz_ = value;
}

// required double Tx = 4;
inline bool pbPosition::has_tx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbPosition::set_has_tx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbPosition::clear_has_tx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbPosition::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
inline double pbPosition::tx() const {
  return tx_;
}
inline void pbPosition::set_tx(double value) {
  set_has_tx();
  tx_ = value;
}

// required double Ty = 5;
inline bool pbPosition::has_ty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbPosition::set_has_ty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbPosition::clear_has_ty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbPosition::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline double pbPosition::ty() const {
  return ty_;
}
inline void pbPosition::set_ty(double value) {
  set_has_ty();
  ty_ = value;
}

// required double Tz = 6;
inline bool pbPosition::has_tz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbPosition::set_has_tz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbPosition::clear_has_tz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbPosition::clear_tz() {
  tz_ = 0;
  clear_has_tz();
}
inline double pbPosition::tz() const {
  return tz_;
}
inline void pbPosition::set_tz(double value) {
  set_has_tz();
  tz_ = value;
}

// -------------------------------------------------------------------

// pbFloatTriblet

// required float x = 1;
inline bool pbFloatTriblet::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbFloatTriblet::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbFloatTriblet::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbFloatTriblet::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float pbFloatTriblet::x() const {
  return x_;
}
inline void pbFloatTriblet::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool pbFloatTriblet::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbFloatTriblet::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbFloatTriblet::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbFloatTriblet::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float pbFloatTriblet::y() const {
  return y_;
}
inline void pbFloatTriblet::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float Z = 3;
inline bool pbFloatTriblet::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbFloatTriblet::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbFloatTriblet::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbFloatTriblet::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float pbFloatTriblet::z() const {
  return z_;
}
inline void pbFloatTriblet::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// pbImage

// optional int32 number = 6;
inline bool pbImage::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbImage::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbImage::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbImage::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 pbImage::number() const {
  return number_;
}
inline void pbImage::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// optional .ladybug5_network.ImageType type = 7;
inline bool pbImage::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbImage::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbImage::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbImage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ladybug5_network::ImageType pbImage::type() const {
  return static_cast< ::ladybug5_network::ImageType >(type_);
}
inline void pbImage::set_type(::ladybug5_network::ImageType value) {
  assert(::ladybug5_network::ImageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes image = 8;
inline bool pbImage::has_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbImage::set_has_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbImage::clear_has_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbImage::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& pbImage::image() const {
  return *image_;
}
inline void pbImage::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void pbImage::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void pbImage::set_image(const void* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbImage::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* pbImage::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbImage::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 size = 9;
inline bool pbImage::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbImage::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbImage::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbImage::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 pbImage::size() const {
  return size_;
}
inline void pbImage::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// optional string name = 11;
inline bool pbImage::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbImage::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbImage::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbImage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& pbImage::name() const {
  return *name_;
}
inline void pbImage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbImage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbImage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbImage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* pbImage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbImage::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 height = 12;
inline bool pbImage::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbImage::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbImage::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbImage::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 pbImage::height() const {
  return height_;
}
inline void pbImage::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// optional uint32 width = 13;
inline bool pbImage::has_width() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbImage::set_has_width() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbImage::clear_has_width() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbImage::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 pbImage::width() const {
  return width_;
}
inline void pbImage::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 packages = 14;
inline bool pbImage::has_packages() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbImage::set_has_packages() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbImage::clear_has_packages() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbImage::clear_packages() {
  packages_ = 0u;
  clear_has_packages();
}
inline ::google::protobuf::uint32 pbImage::packages() const {
  return packages_;
}
inline void pbImage::set_packages(::google::protobuf::uint32 value) {
  set_has_packages();
  packages_ = value;
}

// optional .ladybug5_network.pbDisortion distortion = 15;
inline bool pbImage::has_distortion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbImage::set_has_distortion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbImage::clear_has_distortion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbImage::clear_distortion() {
  if (distortion_ != NULL) distortion_->::ladybug5_network::pbDisortion::Clear();
  clear_has_distortion();
}
inline const ::ladybug5_network::pbDisortion& pbImage::distortion() const {
  return distortion_ != NULL ? *distortion_ : *default_instance_->distortion_;
}
inline ::ladybug5_network::pbDisortion* pbImage::mutable_distortion() {
  set_has_distortion();
  if (distortion_ == NULL) distortion_ = new ::ladybug5_network::pbDisortion;
  return distortion_;
}
inline ::ladybug5_network::pbDisortion* pbImage::release_distortion() {
  clear_has_distortion();
  ::ladybug5_network::pbDisortion* temp = distortion_;
  distortion_ = NULL;
  return temp;
}
inline void pbImage::set_allocated_distortion(::ladybug5_network::pbDisortion* distortion) {
  delete distortion_;
  distortion_ = distortion;
  if (distortion) {
    set_has_distortion();
  } else {
    clear_has_distortion();
  }
}

// optional .ladybug5_network.pbPosition position = 16;
inline bool pbImage::has_position() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void pbImage::set_has_position() {
  _has_bits_[0] |= 0x00000200u;
}
inline void pbImage::clear_has_position() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void pbImage::clear_position() {
  if (position_ != NULL) position_->::ladybug5_network::pbPosition::Clear();
  clear_has_position();
}
inline const ::ladybug5_network::pbPosition& pbImage::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::ladybug5_network::pbPosition* pbImage::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::ladybug5_network::pbPosition;
  return position_;
}
inline ::ladybug5_network::pbPosition* pbImage::release_position() {
  clear_has_position();
  ::ladybug5_network::pbPosition* temp = position_;
  position_ = NULL;
  return temp;
}
inline void pbImage::set_allocated_position(::ladybug5_network::pbPosition* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional string bayer_encoding = 17;
inline bool pbImage::has_bayer_encoding() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void pbImage::set_has_bayer_encoding() {
  _has_bits_[0] |= 0x00000400u;
}
inline void pbImage::clear_has_bayer_encoding() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void pbImage::clear_bayer_encoding() {
  if (bayer_encoding_ != &::google::protobuf::internal::kEmptyString) {
    bayer_encoding_->clear();
  }
  clear_has_bayer_encoding();
}
inline const ::std::string& pbImage::bayer_encoding() const {
  return *bayer_encoding_;
}
inline void pbImage::set_bayer_encoding(const ::std::string& value) {
  set_has_bayer_encoding();
  if (bayer_encoding_ == &::google::protobuf::internal::kEmptyString) {
    bayer_encoding_ = new ::std::string;
  }
  bayer_encoding_->assign(value);
}
inline void pbImage::set_bayer_encoding(const char* value) {
  set_has_bayer_encoding();
  if (bayer_encoding_ == &::google::protobuf::internal::kEmptyString) {
    bayer_encoding_ = new ::std::string;
  }
  bayer_encoding_->assign(value);
}
inline void pbImage::set_bayer_encoding(const char* value, size_t size) {
  set_has_bayer_encoding();
  if (bayer_encoding_ == &::google::protobuf::internal::kEmptyString) {
    bayer_encoding_ = new ::std::string;
  }
  bayer_encoding_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbImage::mutable_bayer_encoding() {
  set_has_bayer_encoding();
  if (bayer_encoding_ == &::google::protobuf::internal::kEmptyString) {
    bayer_encoding_ = new ::std::string;
  }
  return bayer_encoding_;
}
inline ::std::string* pbImage::release_bayer_encoding() {
  clear_has_bayer_encoding();
  if (bayer_encoding_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bayer_encoding_;
    bayer_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbImage::set_allocated_bayer_encoding(::std::string* bayer_encoding) {
  if (bayer_encoding_ != &::google::protobuf::internal::kEmptyString) {
    delete bayer_encoding_;
  }
  if (bayer_encoding) {
    set_has_bayer_encoding();
    bayer_encoding_ = bayer_encoding;
  } else {
    clear_has_bayer_encoding();
    bayer_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string color_encoding = 18;
inline bool pbImage::has_color_encoding() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void pbImage::set_has_color_encoding() {
  _has_bits_[0] |= 0x00000800u;
}
inline void pbImage::clear_has_color_encoding() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void pbImage::clear_color_encoding() {
  if (color_encoding_ != &::google::protobuf::internal::kEmptyString) {
    color_encoding_->clear();
  }
  clear_has_color_encoding();
}
inline const ::std::string& pbImage::color_encoding() const {
  return *color_encoding_;
}
inline void pbImage::set_color_encoding(const ::std::string& value) {
  set_has_color_encoding();
  if (color_encoding_ == &::google::protobuf::internal::kEmptyString) {
    color_encoding_ = new ::std::string;
  }
  color_encoding_->assign(value);
}
inline void pbImage::set_color_encoding(const char* value) {
  set_has_color_encoding();
  if (color_encoding_ == &::google::protobuf::internal::kEmptyString) {
    color_encoding_ = new ::std::string;
  }
  color_encoding_->assign(value);
}
inline void pbImage::set_color_encoding(const char* value, size_t size) {
  set_has_color_encoding();
  if (color_encoding_ == &::google::protobuf::internal::kEmptyString) {
    color_encoding_ = new ::std::string;
  }
  color_encoding_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbImage::mutable_color_encoding() {
  set_has_color_encoding();
  if (color_encoding_ == &::google::protobuf::internal::kEmptyString) {
    color_encoding_ = new ::std::string;
  }
  return color_encoding_;
}
inline ::std::string* pbImage::release_color_encoding() {
  clear_has_color_encoding();
  if (color_encoding_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = color_encoding_;
    color_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbImage::set_allocated_color_encoding(::std::string* color_encoding) {
  if (color_encoding_ != &::google::protobuf::internal::kEmptyString) {
    delete color_encoding_;
  }
  if (color_encoding) {
    set_has_color_encoding();
    color_encoding_ = color_encoding;
  } else {
    clear_has_color_encoding();
    color_encoding_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// pbSensor

// optional uint32 temperature = 1;
inline bool pbSensor::has_temperature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbSensor::set_has_temperature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbSensor::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbSensor::clear_temperature() {
  temperature_ = 0u;
  clear_has_temperature();
}
inline ::google::protobuf::uint32 pbSensor::temperature() const {
  return temperature_;
}
inline void pbSensor::set_temperature(::google::protobuf::uint32 value) {
  set_has_temperature();
  temperature_ = value;
}

// optional uint32 barometer = 2;
inline bool pbSensor::has_barometer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbSensor::set_has_barometer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbSensor::clear_has_barometer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbSensor::clear_barometer() {
  barometer_ = 0u;
  clear_has_barometer();
}
inline ::google::protobuf::uint32 pbSensor::barometer() const {
  return barometer_;
}
inline void pbSensor::set_barometer(::google::protobuf::uint32 value) {
  set_has_barometer();
  barometer_ = value;
}

// optional uint32 humidity = 3;
inline bool pbSensor::has_humidity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbSensor::set_has_humidity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbSensor::clear_has_humidity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbSensor::clear_humidity() {
  humidity_ = 0u;
  clear_has_humidity();
}
inline ::google::protobuf::uint32 pbSensor::humidity() const {
  return humidity_;
}
inline void pbSensor::set_humidity(::google::protobuf::uint32 value) {
  set_has_humidity();
  humidity_ = value;
}

// optional .ladybug5_network.pbFloatTriblet compass = 4;
inline bool pbSensor::has_compass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbSensor::set_has_compass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbSensor::clear_has_compass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbSensor::clear_compass() {
  if (compass_ != NULL) compass_->::ladybug5_network::pbFloatTriblet::Clear();
  clear_has_compass();
}
inline const ::ladybug5_network::pbFloatTriblet& pbSensor::compass() const {
  return compass_ != NULL ? *compass_ : *default_instance_->compass_;
}
inline ::ladybug5_network::pbFloatTriblet* pbSensor::mutable_compass() {
  set_has_compass();
  if (compass_ == NULL) compass_ = new ::ladybug5_network::pbFloatTriblet;
  return compass_;
}
inline ::ladybug5_network::pbFloatTriblet* pbSensor::release_compass() {
  clear_has_compass();
  ::ladybug5_network::pbFloatTriblet* temp = compass_;
  compass_ = NULL;
  return temp;
}
inline void pbSensor::set_allocated_compass(::ladybug5_network::pbFloatTriblet* compass) {
  delete compass_;
  compass_ = compass;
  if (compass) {
    set_has_compass();
  } else {
    clear_has_compass();
  }
}

// optional .ladybug5_network.pbFloatTriblet accelerometer = 5;
inline bool pbSensor::has_accelerometer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbSensor::set_has_accelerometer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbSensor::clear_has_accelerometer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbSensor::clear_accelerometer() {
  if (accelerometer_ != NULL) accelerometer_->::ladybug5_network::pbFloatTriblet::Clear();
  clear_has_accelerometer();
}
inline const ::ladybug5_network::pbFloatTriblet& pbSensor::accelerometer() const {
  return accelerometer_ != NULL ? *accelerometer_ : *default_instance_->accelerometer_;
}
inline ::ladybug5_network::pbFloatTriblet* pbSensor::mutable_accelerometer() {
  set_has_accelerometer();
  if (accelerometer_ == NULL) accelerometer_ = new ::ladybug5_network::pbFloatTriblet;
  return accelerometer_;
}
inline ::ladybug5_network::pbFloatTriblet* pbSensor::release_accelerometer() {
  clear_has_accelerometer();
  ::ladybug5_network::pbFloatTriblet* temp = accelerometer_;
  accelerometer_ = NULL;
  return temp;
}
inline void pbSensor::set_allocated_accelerometer(::ladybug5_network::pbFloatTriblet* accelerometer) {
  delete accelerometer_;
  accelerometer_ = accelerometer;
  if (accelerometer) {
    set_has_accelerometer();
  } else {
    clear_has_accelerometer();
  }
}

// optional .ladybug5_network.pbFloatTriblet gyroscope = 6;
inline bool pbSensor::has_gyroscope() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbSensor::set_has_gyroscope() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbSensor::clear_has_gyroscope() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbSensor::clear_gyroscope() {
  if (gyroscope_ != NULL) gyroscope_->::ladybug5_network::pbFloatTriblet::Clear();
  clear_has_gyroscope();
}
inline const ::ladybug5_network::pbFloatTriblet& pbSensor::gyroscope() const {
  return gyroscope_ != NULL ? *gyroscope_ : *default_instance_->gyroscope_;
}
inline ::ladybug5_network::pbFloatTriblet* pbSensor::mutable_gyroscope() {
  set_has_gyroscope();
  if (gyroscope_ == NULL) gyroscope_ = new ::ladybug5_network::pbFloatTriblet;
  return gyroscope_;
}
inline ::ladybug5_network::pbFloatTriblet* pbSensor::release_gyroscope() {
  clear_has_gyroscope();
  ::ladybug5_network::pbFloatTriblet* temp = gyroscope_;
  gyroscope_ = NULL;
  return temp;
}
inline void pbSensor::set_allocated_gyroscope(::ladybug5_network::pbFloatTriblet* gyroscope) {
  delete gyroscope_;
  gyroscope_ = gyroscope;
  if (gyroscope) {
    set_has_gyroscope();
  } else {
    clear_has_gyroscope();
  }
}

// -------------------------------------------------------------------

// pbMessage

// required string camera = 1;
inline bool pbMessage::has_camera() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbMessage::set_has_camera() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbMessage::clear_has_camera() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbMessage::clear_camera() {
  if (camera_ != &::google::protobuf::internal::kEmptyString) {
    camera_->clear();
  }
  clear_has_camera();
}
inline const ::std::string& pbMessage::camera() const {
  return *camera_;
}
inline void pbMessage::set_camera(const ::std::string& value) {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::kEmptyString) {
    camera_ = new ::std::string;
  }
  camera_->assign(value);
}
inline void pbMessage::set_camera(const char* value) {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::kEmptyString) {
    camera_ = new ::std::string;
  }
  camera_->assign(value);
}
inline void pbMessage::set_camera(const char* value, size_t size) {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::kEmptyString) {
    camera_ = new ::std::string;
  }
  camera_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMessage::mutable_camera() {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::kEmptyString) {
    camera_ = new ::std::string;
  }
  return camera_;
}
inline ::std::string* pbMessage::release_camera() {
  clear_has_camera();
  if (camera_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = camera_;
    camera_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMessage::set_allocated_camera(::std::string* camera) {
  if (camera_ != &::google::protobuf::internal::kEmptyString) {
    delete camera_;
  }
  if (camera) {
    set_has_camera();
    camera_ = camera;
  } else {
    clear_has_camera();
    camera_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 id = 2;
inline bool pbMessage::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbMessage::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbMessage::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 pbMessage::id() const {
  return id_;
}
inline void pbMessage::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool pbMessage::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbMessage::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& pbMessage::name() const {
  return *name_;
}
inline void pbMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void pbMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* pbMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMessage::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ladybug5_network.pbImage Images = 4;
inline int pbMessage::images_size() const {
  return images_.size();
}
inline void pbMessage::clear_images() {
  images_.Clear();
}
inline const ::ladybug5_network::pbImage& pbMessage::images(int index) const {
  return images_.Get(index);
}
inline ::ladybug5_network::pbImage* pbMessage::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::ladybug5_network::pbImage* pbMessage::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ladybug5_network::pbImage >&
pbMessage::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::ladybug5_network::pbImage >*
pbMessage::mutable_images() {
  return &images_;
}

// required .ladybug5_network.LadybugTimeStamp time = 5;
inline bool pbMessage::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbMessage::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbMessage::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbMessage::clear_time() {
  if (time_ != NULL) time_->::ladybug5_network::LadybugTimeStamp::Clear();
  clear_has_time();
}
inline const ::ladybug5_network::LadybugTimeStamp& pbMessage::time() const {
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::ladybug5_network::LadybugTimeStamp* pbMessage::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::ladybug5_network::LadybugTimeStamp;
  return time_;
}
inline ::ladybug5_network::LadybugTimeStamp* pbMessage::release_time() {
  clear_has_time();
  ::ladybug5_network::LadybugTimeStamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline void pbMessage::set_allocated_time(::ladybug5_network::LadybugTimeStamp* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
}

// optional .ladybug5_network.pbSensor sensors = 6;
inline bool pbMessage::has_sensors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbMessage::set_has_sensors() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbMessage::clear_has_sensors() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbMessage::clear_sensors() {
  if (sensors_ != NULL) sensors_->::ladybug5_network::pbSensor::Clear();
  clear_has_sensors();
}
inline const ::ladybug5_network::pbSensor& pbMessage::sensors() const {
  return sensors_ != NULL ? *sensors_ : *default_instance_->sensors_;
}
inline ::ladybug5_network::pbSensor* pbMessage::mutable_sensors() {
  set_has_sensors();
  if (sensors_ == NULL) sensors_ = new ::ladybug5_network::pbSensor;
  return sensors_;
}
inline ::ladybug5_network::pbSensor* pbMessage::release_sensors() {
  clear_has_sensors();
  ::ladybug5_network::pbSensor* temp = sensors_;
  sensors_ = NULL;
  return temp;
}
inline void pbMessage::set_allocated_sensors(::ladybug5_network::pbSensor* sensors) {
  delete sensors_;
  sensors_ = sensors;
  if (sensors) {
    set_has_sensors();
  } else {
    clear_has_sensors();
  }
}

// optional string serial_number = 7;
inline bool pbMessage::has_serial_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbMessage::set_has_serial_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbMessage::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbMessage::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& pbMessage::serial_number() const {
  return *serial_number_;
}
inline void pbMessage::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void pbMessage::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void pbMessage::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbMessage::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* pbMessage::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbMessage::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ladybug5_network

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ladybug5_network::ImageType>() {
  return ::ladybug5_network::ImageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_imageMessage_2eproto__INCLUDED
